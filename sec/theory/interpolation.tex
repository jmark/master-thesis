\subsubsection{Grid Spaces and Transformation}

In this work, four grid spaces are of importance: \emph{Face-centered grid
(FCG)}, \emph{body-centered grid (BCG)}, \emph{Gauss nodal grid (GNG)} and
\emph{Gauss-Lobatto nodal grid (LNG)}. A visual representation can be found in
figure \ref{fig-grid-spaces.png}. This figure shows a one-dimensional grid of
eight cells (dashed lines) or alternatively a grid with two elements (thick
lines) each consisting of four nodes which implies a polynomial order of three.
Major part of the work is the transformation back and forth between these
grid spaces via interpolation. Another significant aspect is the relationship
of elements to cells. First one overlays both grids. Ideally, they are of the
same shape and cover the same physical domain. When transforming between both
grid types, cells get grouped together in numbers equal to the nodal number of
the superincumbent element. Interpolation happens in each group/element
independently.

\image{0.6}{grid-spaces.png}{Nodes in a two element grid each consisting of
four cells. From bottom to top: face-centered, body-centered, Gauss nodes (n =
3), Gauss-Lobatto nodes (n = 3).}

\paragraph{Transformation from \textsc{FLASH} to \textsc{FLEXI}}

All following examples/figures in this document are produced by the very same
procedure where we set the interpolation order $n = 3$. First the intial values
are generated (or read) in the FLASH grid format. The grid is split into groups
of $4^3 = 64$ neighboring cells. These groups get mapped to the associated
element of the HOPR grid. Looping over all group-element pairs a
three-dimensional Lagrange Polynome gets constructed according to the
body-centered values of the cells. Then the new values at the
Gauss/Gauss-Lobatto nodes get interpolated and stored according to the ordering
convention of FLEXI.

In order to do useful analysis and visualization, the FLEXI data gets again
back-interpolated to BCG. This is similar to what the visualization routines in
FLEXI do.

\paragraph{Interpolation Error Estimate}

As a meassure of interpolation error of an original function $f$ and its
interpolated counterfeit $\widetilde{f}$ I opted for the relative
root-means-sqare variance. Taking the absolute error would of course be another
valid option.

\begin{equation}
    \text{rms} = \sqrt{\frac{1}{N} \sum^N_i f^2_i} 
\end{equation}

\begin{equation}
    \text{rmse} = \sqrt{\frac{1}{N} \sum^N_i (f_i - \widetilde{f_i})^2} 
\end{equation}

\begin{equation}
    \text{relative rmse} = \frac{\text{rmse}}{\text{rms}} 
\end{equation}

One has to ensure that $f_i$ and $\widetilde{f_i}$ live in the same grid space.

Another error estimate could be the absolut total error:

\begin{equation}
    \text{tot} = \sum^N_i |f_i|
\end{equation}

\begin{equation}
    \text{rote} = \sum^N_i |f_i - \widetilde{f_i}|
\end{equation}

\begin{equation}
    \text{relative tote} = \frac{\text{tote}}{\text{tot}} 
\end{equation}

In most cases the total absolute error yields smaller results, since runaways
get weighted more in the rmse case. A proper handling of runaways especially in
interpolation of shocks is still an open question.


